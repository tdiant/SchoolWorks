实验一  进程管理（参考实现）
[实验内容]
（1）进程的创建
〈任务〉
编写一段程序，使用系统调用fork( )创建两个子进程。当此程序运行时，在系统中有一个父进程和两个子进程活动。让每一个进程在屏幕上显示一个字符；父进程显示字符“a”，子进程分别显示字符“b”和“c”。试观察记录屏幕上的显示结果，并分析原因。
〈程序〉
#include<stdio.h>
main()
{
int p1,p2;
	if(p1=fork())               /*子进程创建成功*/
    	putchar('b');
	else
	{ 
		if(p2=fork())              /*子进程创建成功*/
  		putchar('c');
    		else putchar('a');           /*父进程执行*/
	}
}

<运行结果>
	bca(有时会出现bac)
分析：从进程执行并发来看，输出bac,acb等情况都有可能。
原因：fork()创建进程所需的时间多于输出一个字符的时间，因此在主进程创建进程2的同时，进程1就输出了“b”，而进程2和主程序的输出次序是有随机性的，所以会出现上述结果。

（2）进程的控制
<任务>
  修改已编写好的程序，将每个程序的输出由单个字符改为一句话，再观察程序执行时屏幕上出现的现象，并分析其原因。如果在程序中使用系统调用lockf()来给每个程序加锁，可以实现进程之间的互斥，观察并分析出现的现象。

〈程序1〉
#include<stdio.h>
main()
{
	int p1,p2,i;
	if(p1=fork())
 		for(i=0;i<500;i++)
		        printf("child %d\n",i);
	else
	{ 
 	if(p2=fork())
    		for(i=0;i<500;i++) 
			printf("son %d\n",i);
 	else
    		for(i=0;i<500;i++)  
			printf("daughter %d\n",i);
	}
}
〈运行结果〉

	child….
	son…
	daughter…
	daughter…
	或child
	…son
	…child
	…son
	…daughter
	分析：由于函数printf()输出的字符串之间不会被中断，因此，字符串内部的字符顺序输出时不变。但是 , 由于进程并发执行时的调度顺序和父子进程的抢占处理机问题，输出字符串的顺序和先后随着执行的不同而发生变化。这与打印单字符的结果相同。

〈程序2〉
#include<stdio.h>
main()
{
	int p1,p2,i;
	if(p1=fork())
	{
     	lockf(1,1,0);
     	for(i=0;i<500;i++)  
		printf("child %d\n",i);
     		lockf(1,1,0);
	}
	else
 	{
  		if(p2=fork())
			{ 
			lockf(1,1,0);
     			for(i=0;i<500;i++)  printf("son %d\n",i);
    			lockf(1,1,0);
  			}
		else
		{ 
		lockf(1,1,0);
     		for(i=0;i<500;i++)  printf("daughter %d\n",i);
   	 	lockf(1,0,0);
		}
	 }
}


<运行结果〉

大致与未上锁的输出结果相同，也是随着执行时间不同，输出结果的顺序有所不同。
分析：因为上述程序执行时，不同进程之间不存在共享临界资源（其中打印机的互斥性已有由操作系统保证）问题，所以，加锁与不加锁效果相同。